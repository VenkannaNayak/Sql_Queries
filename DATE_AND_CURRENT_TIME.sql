
use adf
--DECLARED DATES
DECLARE @date date = '2023-06-21',
@origin date = '2023-06-05';
SELECT 
   DATE_BUCKET(day, 1, @date, @origin) AS "1 day",
   DATE_BUCKET(day, 2, @date, @origin) AS "2 days",
   DATE_BUCKET(day, 3, @date, @origin) AS "3 days",
   DATE_BUCKET(day, 4, @date, @origin) AS "4 days";
   --DATE ADDED
   SELECT DATEADD(DAY,7,'2023-06-16') AS CURRENT_DAY_OF_DATES
   --YEARS ADDED
   SELECT DATEADD(YEAR,7,'2023-06-27') AS CURRENT_YEARS
   --MONTH ADDED
   SELECT DATEADD(MONTH,2,'2023-06-28') AS MONTH_ADDED
   --YEAR ADDED
   SELECT DATEDIFF(YY,2,GETDATE())
   --YEAR DIFFERENCES;
   SELECT DATEDIFF(YEAR,'2023-06-16','2028-06-10') AS DATE_INFO
   --MONTH DIFFERENCES;
   SELECT DATEDIFF(MONTH,'2023-06-20','2023-10-20') AS DATE_DIFFERENCES
   --DAY DIFFERENCES;
   SELECT DATEDIFF(DAY,'2023-06-25','2023-06-28') AS DAY_DIFFERENCES
   --DATENAME IN YEAR
   SELECT DATENAME(YEAR,'2023-08-18') AS TO_SEA_THE_DATE_NAME
   --DATE IN MONTH
   SELECT DATENAME(MONTH,'2023-06-16') AS TO_BE_SEA_THE_MONTH_NAME
   --DATE IN YEARS
   SELECT DATENAME(DAY,'2023-06-27') AS TO_BE_SEA_THE_DAYS
   --DATE_TIMES_TO_PARTS
   SELECT DATETIME2FROMPARTS(2023,02,20,03,00,30,0,0) AS DATE_FORMATS
   --EOMONTHS
   SELECT EOMONTH('2023-06-17') AS END_DATE
   --NUMBR OF DAYS IN AMONTHS:
   SELECT DAY(EOMONTH(CURRENT_TIMESTAMP)) AS END_OF_DAY
  --NUMBER OF MONTHS IN YEARS
 --string functions
 --ASCII VALUES:
 SELECT ASCII('VENKANNA') AS ASCIVALUES_AS_VENKANNA
 SELECT ASCII('SQL_STRUCTURE_QUERY_WITH_HELP_OF_SQL_SERVER_WRITEN_BY_THIS_QUERY_MYSELF')AS OF_ASCII_VALEUS
 SELECT ename,ASCII(ename)AS ENAME_OF_ASCII_VALEUS_EACH FROM MY_TAB
 --WITH CHAR
 SELECT CHAR(72) AS CHARS_OF_72,CHAR(200) AS CHARS_OF_10,CHAR(86) AS CHARS_VALUES_OF_86
 SELECT 'HELLO' + CHAR(10) + 'MY_NAME' AS CHAR_FUNCTION
 SELECT ENAME,CHAR(eno) AS ENAME_VALEUS FROM my_tab
 --CHAR INDEX
 SELECT CHARINDEX('E','VENKANNA') AS INDEXS_FIND
 SELECT ENAME, CHARINDEX('R',ENAME) AS CHAR_INDEX FROM MY_TAB
 --CONCAT_WS AND CONCAT
 SELECT CONCAT_WS('_','MY NAME IS', 'VENKANNA') AS CONCAT_WS_NAME
 SELECT CONCAT_WS(' ','V','E','N','K','Y') AS CONCAT_NAME
SELECT ENO,ENAME,CONCAT_WS('--->',ENO,ENAME) AS CONCAT_WS_FROM_MY_TAB FROM my_tab
SELECT CONCAT('MY ANME IS VENKANNA AZURE DATA ENGINEERING','_ECLASESS') AS CONCAT_LINE
SELECT ENO,ENAME ,CONCAT(ENO,ENAME) AS FIND_ID_ENAME FROM my_tab
--sonudex
SELECT SOUNDEX(ENAME) AS ENAME FROM my_tab
SELECT SOUNDEX('VENKYANNA') AS NAMES,SOUNDEX('MUNAVATH') AS FNAMES,DIFFERENCE('VENKYANNA','MUNAVATH') AS DIFFERENCES
--ESCAPE STRING
SELECT STRING_ESCAPE('https://wwww.facebook.com','json') as file_into_json
--FORMATS:
DECLARE @DATE DATE = '04/20/2023'; 
SELECT FORMAT(@DATE, 'MM/dd/yyyy', 'EN-US') AS 'DATE';
SELECT FORMAT(456797,'$#,###,##.00') AS CUSTOMS
SELECT ENO,FORMAT(eno,'C') AS CURRENCY FROM my_tab
--LEFT AND LEN
SELECT LEFT('ENAME',2) ASLEFTFUN
SELECT ENAME,LEN(ENAME)AS LENGTH_FUN FROM my_tab
--LTRIM,RTRIM,PARTINDEX
SELECT ENAME, PATINDEX('%a%', ENAME) AS PATINDEX_a FROM my_tab; 
--QOUTENAME
SELECT ENAME,QUOTENAME(ENAME,'()') AS QOUTENAMES FROM MY_TAB 
--REPLICATE
SELECT ENAME,REPLICATE(ENAME,2) AS REPEAT_NAME FROM my_tab
--REVERSE
SELECT ENAME,REVERSE(ENAME) FROM  my_tab
--SPACE
SELECT SPACE(10) AS S_NAME_SPACE
--STR
SELECT STR(245.67,5,8)AS _VALUE
--STRING SPLIT
 SELECT VALUE FROM string_split('MUNAVATH VENKANNA I MA FROM HYDERABA WITH STUDYING INTO',' ')
 --STUFF ONE STRING TO ANOTHER STRING AND SUBSTRING
SELECT STUFF('VENKANNA',2,2,'NAYAK') AS STUFF_STRING
SELECT SUBSTRING('VENKANNA',2,2) AS SUBSTRINGS
--TRANSLATE VAUE WITH FIRST LETTERS
SELECT TRANSLATE('venkanna munavath','vm','VM') as translate_values_of_letters
--unicode
SELECT UNICODE('HELLO_VENKANNA') AS UNIC_CODES
--STDEV
SELECT STDEV(SAL) AS STDEV_SALARY FROM  MY_TAB
--STDEVP
SELECT STDEVP(SAL) AS STDEVP FROM MY_TAB
--VARP
SELECT VARP(SAL) as STR_VARP FROM MY_TAB
--@@CONNECTIONSATTEMPTS
SELECT [CONNECTIONATTEMPTS]=@@CONNECTIONS
SELECT [ConnectionAttempts] = @@CONNECTIONS,[Max_allowed] = @@MAX_CONNECTIONS;
--TIMETICKS
SELECT @@TIMETICKS AS TIME_IN_MICROSECONDS

--IMAGES DISPLAY QUERY

CREATE TABLE Images (
    ImageId INT IDENTITY(1,1) PRIMARY KEY,
    ImageData VARBINARY(MAX)
);

select * from Images
SELECT * FROM my_tab1
INSERT INTO Images (ImageData)
SELECT BulkColumn
FROM OPENROWSET(BULK 'C:\Users\Dell\Downloads\tiger.jpg', SINGLE_BLOB) AS Image;

SELECT  ImageData
FROM Images
WHERE ImageId = 1;

--CREATING VIEWS
CREATE VIEW MY_TAB_V AS
SELECT ENAME,SAL FROM my_tab1

SELECT * FROM MY_TAB_V

--UPDATING VIEW
-- Drop the existing view if it exists
IF OBJECT_ID('MY_TAB_UPDATE', 'V') IS NOT NULL
    DROP VIEW MY_TAB_UPDATE;
GO
-- Create the view
CREATE VIEW MY_TAB_UPDATE AS
SELECT ENAME, SAL
FROM MY_TAB1;
GO

SELECT * FROM MY_TAB_UPDATE
--HOW TO SEA THE PR KEYS
SELECT * FROM SYS.objects WHERE TYPE='PK'
--HOW TO SEA THE LIST OF FK KEYS
SELECT * FROM SYS.objects WHERE TYPE='F'
--HOW TO SEA THE USER TABLES
SELECT * FROM SYS.objects WHERE TYPE='U'
--HOW TO SEA THE UNIQUE IDS
SELECT * FROM sys.objects WHERE TYPE='UQ'
--TRIGGERS IS THE  SORT OF EVENT BASED LISTENERS
SELECT * FROM SYS.objects WHERE TYPE='TR'
--INTERNAL TRIGGERS
SELECT * FROM SYS.objects WHERE TYPE='IT'
--LIST OF PROCEDURES
SELECT * FROM SYS.objects WHERE TYPE='P'

--CTEATION OF TWO TABELS

-- Create the first table
CREATE TABLE Table1 (
  ID INT,
  Name VARCHAR(50),
  Age INT,
  City VARCHAR(50),
  Email VARCHAR(50),
  Phone VARCHAR(15)
);

-- Create the second table
CREATE TABLE Table2 (
  ID INT,
  Department VARCHAR(50),
  Salary DECIMAL(10, 2),
  StartDate DATE,
  IsActive BIT,
  Address VARCHAR(100)
);

-- Insert records into Table1
INSERT INTO Table1 (ID, Name, Age, City, Email, Phone)
VALUES (1, 'John', 25, 'New York', 'john@example.com', '123-456-7890'),
       (2, 'Emily', 32, 'Los Angeles', 'emily@example.com', '987-654-3210'),
       (3, 'Michael', 41, 'Chicago', 'michael@example.com', '456-789-0123'),
       (4, 'Sophia', 28, 'San Francisco', 'sophia@example.com', '789-012-3456'),
       (5, 'William', 37, 'Boston', 'william@example.com', '234-567-8901'),
       (6, 'Olivia', 19, 'Seattle', 'olivia@example.com', '901-234-5678'),
       (7, 'James', 56, 'Houston', 'james@example.com', '567-890-1234'),
       (8, 'Ava', 33, 'Miami', 'ava@example.com', '321-654-0987'),
       (9, 'Benjamin', 46, 'Dallas', 'benjamin@example.com', '890-123-4567');

-- Insert records into Table2
INSERT INTO Table2 (ID, Department, Salary, StartDate, IsActive, Address)
VALUES (1, 'Sales', 5000.00, '2022-01-01', 1, '123 Main St'),
       (2, 'HR', 6000.00, '2021-11-01', 1, '456 Elm St'),
       (3, 'IT', 7000.00, '2020-03-15', 1, '789 Oak Ave'),
       (4, 'Finance', 5500.00, '2023-05-01', 0, '321 Pine Rd'),
       (5, 'Marketing', 4800.00, '2022-09-10', 1, '654 Maple Ln'),
       (6, 'Operations', 5200.00, '2022-07-01', 1, '987 Cedar St'),
       (7, 'Legal', 7500.00, '2022-04-01', 1, '234 Birch Ave'),
       (8, 'Engineering', 8000.00, '2021-12-05', 1, '567 Spruce Rd'),
       (9, 'Administration', 4000.00, '2023-01-15', 0, '890 Walnut Ln');

-- Query the records from Table1
SELECT * FROM Table1;

-- Query the records from Table2
SELECT * FROM Table2;
--TO FINDOUT THE RANK
SELECT TOP 5 * FROM Table1 WHERE AGE>25

SELECT * FROM Table1  INNER JOIN Table2 ON Table1.ID=Table2.ID

SELECT T2.ID,T2.Address,T2.IsActive ,T2.Salary AS T1 FROM Table1 INNER JOIN Table2 AS T2 ON T2.ID=T2.ID

SELECT * FROM Table1 WHERE ID IN (SELECT ID FROM Table1 WHERE AGE>25)

--HAVING CLAUSE
SELECT COUNT(ID) AS COUNTED_IDS FROM Table1 GROUP BY ID HAVING COUNT(ID)>0

SELECT AVG(AGE)AS AVG_AGE,MIN(AGE)AS MIN_AGE,MAX(AGE)AS MAX_AGE FROM Table1 WHERE ID IN (SELECT ID FROM Table1)

--use adf
use adf
SELECT * FROM Table2

SELECT NAME,AGE,PHONE FROM Table1 WHERE EXISTS (SELECT ID FROM Table2 WHERE Table1.ID=Table2.ID AND AGE<25)

SELECT NAME,AGE,PHONE FROM Table1 WHERE EXISTS (SELECT ID FROM Table2 WHERE Table1.ID=Table2.ID AND AGE>35)

--COALSECE-TO REDUCED THE NUMBER OF PARTITIONS IN SQL SERVER
SELECT COALESCE(NULL,NULL,PHONE,NULL)AS COALESCE_FUN FROM Table1

SELECT * FROM Table2
--DENSE_RANK/RANK,ROW_NUMBER()
SELECT ID,NAME,AGE, DENSE_RANK() OVER(PARTITION BY ID ORDER BY NAME)AS DENSE_RANKS FROM Table1

select *,
RANK() OVER(ORDER BY SALARY ASC) AS RANKS,
ROW_NUMBER() OVER(ORDER BY SALARY ASC) AS ROW_NUMBERS,
DENSE_RANK() OVER(ORDER BY SALARY ASC) AS DENSE_RANKS FROM Table2;

--AVG(SALARY)
SELECT ID,DEPARTMENT,ADDRESS ,AVG(SALARY) OVER() AS AVG_SLARIES FROM Table2 WHERE EXISTS (SELECT DEPARTMENT FROM Table2)
SELECT ID,DEPARTMENT,ADDRESS ,MAX(SALARY) OVER() AS MAX_SLARIES FROM Table2 WHERE EXISTS (SELECT DEPARTMENT FROM Table2)
SELECT ID,DEPARTMENT,ADDRESS ,MIN(SALARY) OVER() AS MIN_SLARIES FROM Table2 WHERE EXISTS (SELECT DEPARTMENT FROM Table2)

SELECT DEPARTMENT,COUNT(*)AS TOTAL_COUNTS,AVG(SALARY)AS AVG_SAL,MIN(SALARY)AS MIN_SAL,MAX(SALARY)AS MAX_SAL FROM Table2 GROUP BY DEPARTMENT
HAVING TOTAL_COUNTS > 500 AND AVG_SAL > 25

SELECT SALARY, COUNT(*) AS TOTAL_COUNTS, AVG(SALARY) AS AVG_SAL, MIN(SALARY) AS MIN_SAL, MAX(SALARY) AS MAX_SAL
FROM Table2
GROUP BY SALARY
HAVING COUNT(*) > 500 AND AVG(SALARY) > 2500;

SELECT ID,ADDRESS,SALARY,LAG(SALARY,1,0) OVER(PARTITION BY ID ORDER BY SALARY ASC) AS LAGG_FUNC FROM Table2

SELECT ID,ADDRESS,SALARY, 
LAG(SALARY,1,0) OVER(PARTITION BY ID ORDER BY SALARY ASC) AS LAGG_FUNCTION,
LEAD(SALARY,1,0) OVER(PARTITION BY ID ORDER BY SALARY ASC) AS LEAD_LAG
FROM Table2:

--PERCENT_RANK()
SELECT ID, ADDRESS, SUM(SALARY) AS _TOTAL_SAL, PERCENT_RANK() OVER (ORDER BY SUM(SALARY)) AS SALARIES_PERCENT_RANK
FROM Table2
GROUP BY ID, ADDRESS
HAVING SUM(SALARY) > 4000
ORDER BY ID;
--CORR
SELECT ID, ADDRESS, (
    SELECT (SUM((SYSDATE - JOINING_DATE) * (SALARY - AVG_SAL)) / (COUNT(*) * STDDEV(SYSDATE - JOINING_DATE) * STDDEV(SALARY))) 
    FROM Table2
) AS VOERS_RESULT
FROM Table2;
USE adf
--VARIANCE/POP/SAMP
SELECT VARIANCE(SALARY)AS VARIANCE_SAL,
       VAR_POP(SALARY)AS POP_SAL,
	   VAR_SAMP(SALARY)AS SAMP_SAL
	   FROM TABLE2;
--NITILE
SELECT NAME,AGE,PHONE,NTILE(6) OVER(ORDER  BY AGE)AS NITILES FROM TABLE1

SELECT ADDRESS,SALARY,NTILE(7) OVER(ORDER BY SALARY ASC)AS NTILE_SALARY FROM Table2

SELECT AVG(SALARY) * AVG(SALARY)+ AVG(SALARY) * AVG(SALARY) AS AVG_SALARIES FROM Table2
--FIRST VALUE
SELECT ID, SALARY, FIRST_VALUE(SALARY) OVER(PARTITION BY ID ORDER BY SALARY ASC) AS FIRST_VALUES
FROM TABLE2 WHERE SALARY IS NOT NULL
--LAST_VALUES
SELECT ID,ADDRESS,SALARY,LAST_VALUE(SALARY) OVER(PARTITION BY ID ORDER BY SALARY DESC) AS LAST_VALUES FROM Table2
WHERE SALARY IS NOT NULL




















